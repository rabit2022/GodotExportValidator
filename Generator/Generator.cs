using Microsoft.CodeAnalysis;
using System;
using System.Text;
using System.Collections.Generic;
using System.Linq;

namespace GodotExportValidator.SourceGenerator
{
    /// <summary>
    /// 入口类
    /// </summary>
    [Generator]
    public class Generator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // 收集目标字段
            var nodes = context.SyntaxProvider.ForAttributeWithMetadataName(
                "GodotExportValidator.ValidateAttribute",
                (node, _) => true,
                (node, _) => node
            ).Collect();

            context.RegisterSourceOutput(nodes, (c, d) => new SourceProvider(c).Process(d));
        }
    }

    public class SourceProvider
    {
        private SourceProductionContext context;

        public SourceProvider(SourceProductionContext context)
            => this.context = context;

        /// <summary>
        /// 生成代码
        /// </summary>
        public void Process(IEnumerable<GeneratorAttributeSyntaxContext> data)
        {
            var comparer = SymbolEqualityComparer.Default;
            var groupedByClass = data.GroupBy(x => x.TargetSymbol.ContainingType, comparer);
            foreach (var group in groupedByClass)
            {
                ProcessClass((INamedTypeSymbol)group.Key, group.AsEnumerable());
            }
        }

        private void ProcessClass(INamedTypeSymbol @class, IEnumerable<GeneratorAttributeSyntaxContext> group)
        {
            var source = new StringBuilder();
            // BuildingComponent_Validate.generate
            var filename = $"{@class.ToDisplayString()}_Validate.generate.cs";
            source.AppendLine($"// {filename} auto-generated by GodotExportValidator");

            // using GodotExportValidator
            source.AppendLine("using GodotExportValidator;");

            if (!@class.ContainingNamespace.IsGlobalNamespace)
            {
                var @namespace = @class.ContainingNamespace.ToDisplayString();
                source.AppendLine($"namespace {@namespace};");
                source.AppendLine();
            }

            source.AppendLine($"partial class {@class.Name}");
            source.AppendLine("{");

            CreateOnValidateMethod(source, group);

            source.AppendLine("}");
            source.AppendLine();
            context.AddSource(filename, source.ToString());
        }

        private void CreateOnValidateMethod(StringBuilder source, IEnumerable<GeneratorAttributeSyntaxContext> group)
        {
            source.AppendLine("private void OnValidate()");
            source.AppendLine("{");

            foreach (var attribute in group)
            {
                source.AppendLine(WriteAttribute(attribute));
            }

            source.AppendLine("}");
        }

        string WriteAttribute(GeneratorAttributeSyntaxContext attribute)
        {
            var fieldOrProperty = attribute.TargetSymbol;
            // switch
            var type = (attribute.TargetSymbol is IFieldSymbol f ? f.Type :
                attribute.TargetSymbol is IPropertySymbol p ? p.Type : throw new InvalidOperationException()).WithNullableAnnotation(NullableAnnotation.None);

            var name = fieldOrProperty.Name;
            // var path = ResolvePath(attribute.Attributes, name);

            // return $"    private {type} {name} => {fieldOrProperty.Name} ??= GetNode<{type}>(\"{path}\");";

            // 1. 字符串
            if (type.SpecialType == SpecialType.System_String)
                return $"ValidateUtilities.ValidateCheckEmptyString(this, \"{name}\", {name});";

            // 2. 数组（任何 T[]）
            if (type is IArrayTypeSymbol)
                return $"ValidateUtilities.ValidateCheckEnumerableValues(this, \"{name}\", {name});";

            // 3. 泛型 IEnumerable<T>
            var gt = type as INamedTypeSymbol;
            // var symbol = gt;
            if (gt != null && gt.IsGenericType && gt.OriginalDefinition.SpecialType == SpecialType.System_Collections_Generic_IEnumerable_T)
                return $"ValidateUtilities.ValidateCheckEnumerableValues(this, \"{name}\", {name});";

            // 4. 非泛型 IEnumerable（ArrayList、Queue、DataRowCollection …）
            if (type.AllInterfaces.Any(i => i.SpecialType == SpecialType.System_Collections_IEnumerable))
                return $"ValidateUtilities.ValidateCheckEnumerableValues(this, \"{name}\", {name});";

            // 5. 可空值类型
            if (type.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T)
                return $"ValidateUtilities.ValidateCheckNullValue(this, \"{name}\", {name});";

            // 6.int,float
            if (type.SpecialType == SpecialType.System_Int32 || type.SpecialType == SpecialType.System_Single)
                return $"ValidateUtilities.ValidateCheckPositiveValue(this, \"{name}\", {name}, false);";


            // 6. 其余（值类型已排除空值，引用类型判空）
            return $"ValidateUtilities.ValidateCheckNullValue(this, \"{name}\", {name});";
        }
    }
}